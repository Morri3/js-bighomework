# [2021-2022学年第2学期](https://js-sigcc.vercel.app/#/lab/proj.final?id=_2021-2022学年第2学期)

# [**实 验 报 告**](https://js-sigcc.vercel.app/#/lab/proj.final?id=实-验-报-告)

![zucc](https://js-sigcc.vercel.app/zucc.png)

- 课程名称:跨平台脚本开发技术
- 实验项目:期末大作业
- 专业班级<u>计算1902、计算1902</u>
- 学生学号<u>31901060、31901061</u>
- 学生姓名<u>张亦骞、张泽峰</u>
- 实验指导教师:郭鸣

## [实验内容](https://js-sigcc.vercel.app/#/lab/proj.final?id=实验内容)

1. ~~翻译英文 每人5页.~~
2. （选做）完成一个介绍JS进展的技术报告,要求如下，附加分。
   - 内容范围
     - Javascript语言新技术动向
       - 如 async await, generator,webassembly, web socket,Service Worker, Reflect API 等
     - Javascript框架 vue, cyclejs,infernojs, sveltejs,hyperapp... 介绍框架原理,使用案例.
     - Javascript 某个技术实现 Vdom,GraphQL
     - 技术报告范例参考[500 Lines or Less](http://www.aosabook.org/en/index.html)
   - 提交形式
     - 提交 code + markdown文档
   - 技术报告讲座 (可选,加分)
     - 预计 20分钟左右,下下周开始
     - 制作 ppt (markdown)
   - 自我评估 5为最高
     - 原创性 (1-5)
     - 技术难度 (1-5)
     - 工作量 (1-5)
3. 大项目,分组完成,评分方式，以下为起始评分
   - 及格 在现有的项目代码
     - 现有代码修改与改进
     - 客户端有服务器API发起网络调用
     - 有简单的服务器处理逻辑
     - 能解释服务器REST API接口
     - 能展示 网络请求的 Request Response 数据
   - 中 采用前端框架,实现应用跨平台的适配，Desktop, Tablet, Mobile
     - 对现有功能有较多改进
   - 优秀/良 完成自定义项目.
     - 使用比较有特点JavaScript框架
       - solidjs/hyper/elm
     - 采用比较新颖的技术 例如FRP PWA Service Worker等
       - 函数式编程
       - 响应式编程
     - 项目有创新性与技术难度
4. 现有改进方式建议列表
   - 开发技术
     - UI 响应式设计
       - 采用 BootStrap, Material Design等前端框架
       - 支持 Desktop, Tablet, Mobile
     - 服务端 NodeJs框架
       - Express、Koa等实现服务端
     - WebSocket socket.io等实时交互技术
     - Web Assembly技术
5. 项目信息参考
   - 平台游戏 or 2048
     - 添加用户登录
       - 用户登录id 会话保存
       - 用户头像保存
     - 管理员后台
       - CRUD操作
     - 用户积分排行
       - 积分排行存储到本地
       - 积分排行存储到服务器
     - 实现游戏手机平台，平板的支持
     - 在线关卡编辑器
     - 5 * 5 2048
     - Time travel 编译器compiler/debugger
       - Cyclejs Time traveler
   - JS语言创新 在js 中实现其他语言的语法特性
     - https://github.com/slurmulon/flap
     - https://github.com/sanctuary-js/sanctuary
     - http://www.sweetjs.org/
6. git 管理技术文档,和项目代码,可以使用 github desktop
   - 验收大作业的时候查看git log
   - npm i -g git-stats
   - https://github.com/tomgi/git_stats/graphs/contributors
7. 代码风格 standard https://standardjs.com/readme-zhcn.html
8. 项目分工表格

- 1人项目权重为1.0
- 2人项目权重和为 1.9

|  姓名  |   学号   |   班级   |                       任务                       | 权重 |
| :----: | :------: | :------: | :----------------------------------------------: | ---- |
| 张亦骞 | 31901060 | 计算1902 | 功能设计，游戏实现，nodejs服务器搭建，5*5模式，  | 0.95 |
| 张泽峰 | 31901061 | 计算1902 | 功能设计，首页，我的界面，登录模块，排行榜模块， | 0.95 |

1. 项目自我评估表（0-5）

| 函数式编程 | xhr fetch api | FRP  |     session Storage     | 响应式编程 | REST API | flap                              |
| :--------: | :-----------: | :--: | :---------------------: | :--------: | :------: | --------------------------------- |
|     5      |               |      |                         |            |    5     | 2                                 |
|  纯函数√   |   Promise√    |      | 微信小程序localStorage√ |            |          | https://github.com/slurmulon/flap |

1. 项目自评等级:(1-5)

   等级：

   

2. 项目说明

   1. 使用的技术

   |      前端      |  后端   |
   | :------------: | :-----: |
   |   微信小程序   | nodejs  |
   | js（业务逻辑） | express |
   |       /        |   js    |
   |       /        |  mysql  |

   

   2. 项目是基于现有的2048代码

      参考的代码来自：https://github.com/windlany/wechat-weapp-2048

      *<u>注：微信小程序（以下简称客户端），nodejs服务器（以下简称服务器），mysql数据库（以下简称数据库）</u>*

   - **改进 2048游戏界面。**

   - **开发当前得分、最高分、增加重新开始游戏功能模块。**

     ​		游戏厅界面分为上面和下面两块区域。

     ​		上面区域从左至右分别是：2048游戏名标题、重新开始按钮、当前得分、最高分。

     ​		点击重新开始按钮，用户可以在【一局进行中的游戏】进行重新开始一局游戏的操作。代码如下：

     ```js
       //一局游戏结束点击重新开始按钮
       restart() {
         this.setData({
           isFinished: false
         })
     
         //开始游戏
         this.start();
       },
     ```

     ​		当前得分显示用户在当前操作后所获得的分数，分数计算方法是在棋盘中找到最大数字的格子，取该最大数字为当前得分。代码如下：

     ```js
     	//取当前这一刻的最好成绩（即棋盘中存在的最大数字）
         var max = 0; //最大值
         for (var i = 0; i < this.data.size; i++) {
           for (var j = 0; j < this.data.size; j++) {
             if (data[i][j] !== "" && data[i][j] > max) { //当前格子不为空且数字大于max
               max = data[i][j]; //找到当前棋盘中最大的，设置为当前成绩
             }
           }
         }
     ```

     ​		当用户在游戏入口页（即首页）点击开始游戏按钮进入到游戏厅时，客户端向服务器发送网络请求，获取数据库中user表的当前用户的最高普通模式的成绩，把它set到game.js页面。代码详见【开发 服务器端（1）游戏厅的网络请求部分】。

     ------------------------------------------------------------------------------------------------------------------------------------------------------

     ​		下面区域为2048棋盘。棋盘绘制与生成主要涉及到game.js、manager.js、grid.js三个js文件。

     ​		manager.js、grid.js通过使用`module.exports = Manager;`和`module.exports = Grid;`让其他js文件使用其中的方法和属性。

     ​		game.js为主入口文件。在游戏厅当前页面的onReady生命周期中，首先调用start()开始游戏函数，该函数的过程如下：

     1、创建一个棋盘管理类，并setData到game.js。

     （1）调用Manager的构造函数，把棋盘大小4传给Manager.js。设置棋盘大小，初始化填充的格子个数为2（第一个棋盘中会出现2个有数字的格子）。

     ```js
     function Manager(size) { 
       this.size = size;//棋盘的大小。从2048.js传入
       this.fillNum = 2;//填充的个数。初始填充2个格子
       this.init();//初始化
     }
     ```

     （2）调用Grid的构造函数，把棋盘大小4传给Grid.js。生成一个空的二维数组，返回给Manager管理类的checkerboard对象。

     ```js
     	var grid = []; //二维数组
         for (var i = 0; i < this.size; i++) {
           grid[i] = []; //每一行都是一个空数组
           for (var j = 0; j < this.size; j++) {
             grid[i].push(""); //每一行的每一个格子都是空的
           }
         }
         return grid;
     ```

     （3）使用`this.bproto = this.checkerboard.__proto__;`获取checkerboard在Grid中的父对象，以使用Grid中调用的方法和属性。

     （4）调用getRandomCell函数随机填充格子。

     ​		首先调用checkerboard父对象的isCellEmpty方法判断棋盘是否有可用的空格子，有的话就添加数字。数字的生成方法是：

     ```js
     var value = Math.random() < 0.9 ? 2 : 4;//生成10%的4，90%的2
     ```

     ​		接着在可填充的格子中【调用checkerboard的selectCell方法】随机选择一个格子作为要填充的格子。可填充的格子是通过遍历棋盘这个二维数组，找到值是""的格子，把该格子的x和y坐标push到一个数组中，返回回去。

     ```js
       //从可使用的空格子中随机选一个
       selectCell() {
         var emptyCells = this.findEmptyCell(); //所有空格子
         if (emptyCells.length) { //若存在空格子
           return emptyCells[Math.floor(Math.random() * emptyCells.length)]; //随机返回这些空格子中的一个
           //Math.random()生成[0,1)的随机数
           //Math.floor对生成的随机数向下取整
           //如emptyCells[2]表示第三个可用的空格子，存有该格子的x和y坐标值
         }
       },
     ```

     ​		然后把生成的随机数赋给刚才随机选择的格子。

     ​		最后更新棋盘数据，把上面得到的格子的x坐标和y坐标传给checkerboard的grid。

     （5）把接下来每一次随机生成的格子的个数变为1。即把manager对象的fillNum属性赋值为1。

     2、把棋盘管理类manager的父类型赋值给game.js中manager对象。

     ```js
     this.data.manager.__proto__ = manager.__proto__; //让this.data中的manager对象能使用manager对象的父类型的方法和属性
     ```

     3、设置hidden、isFinished、score等变量的初始化，并把checkerboard的grid棋盘赋值给game.js的grids，这样就能在页面中显示使用棋盘。

     ----------------------------------------------------------------------------------------------------------------------------

     ​		用户在棋盘上的滑动格子操作具体如下：

     1、通过在game.wxml绑定touchStart、touchMove和touchEnd函数监听触摸的操作。

     （1）初始化touchStartX、touchStartY、touchEndX、touchEndY四个变量为0

     （2）滑动格子，分别记录开始滑动时的x、y坐标，最后移动时的x、y坐标，在滑动格子的操作结束后，分别计算x、y轴上滑动的距离的绝对值。然后判断棋盘中是否有可以滑动合并的格子，有就表示未结束，没有就表示这局游戏结束了。

     （2-1）游戏结束，就保存成绩等数据到数据库。

     （2-2）游戏未结束，判断是否滑动【以上下或左右滑动距离大于10px为判断标准，即`if (Math.max(absdisX, absdisY) > 10) {...}`】，有滑动就让棋盘中的格子按指定滑动方向滑动，并合并能合并的格子。然后更新棋盘。

     2、四个方向移动格子的实现

     （1）将滑动方向标记为   0:上, 1:右, 2:下, 3:左

     （2）根据滑动方向获得一个数组list，该数组包含四个子数组，即`list = [[], [], [], []];`遍历棋盘这个二维数组。通过switch-case实现对不同方向的选择：

     ​		若是向上滑动，则list的每一个子数组都是从上边开始往下遍历；

     ​		若是向右滑动，则list的每一个子数组都是从右边开始往左遍历；

     ​		若是向下滑动，则list的每一个子数组都是从下边开始往上遍历；

     ​		若是向左滑动，则list的每一个子数组都是从左边开始往右遍历。

     （3）根据步骤（2）生成的list数组，合并能够合并的格子。

     （3-1）首先，遍历list的四个子数组，调用changeItem函数把数字向棋盘边界靠拢。

     ​		如原先是['', 2, '', 2]，经过changeItem函数变为[2, 2, '', '']。

     ```js
       //改变数字位置
       changeItem(item) {//把['', 2, '', 2]改为[2, 2, '', '']
         var cnt = 0;//遍历的下标
         //以向上滑动为例，当前list数组的第一个子数组为[0,2,2,0]
         //i=1时，格子为2，cnt=0，item[0]=item[1]=2
         //i=2时，格子为2，cnt=1，item[1]=item[2]=2
         for(var i = 0; i < item.length; i++){//遍历每个list的子数组
           if(item[i]!=='') {//格子不为空
             item[cnt++] = item[i];
           }
         }
         //上述例子中，cnt=1
         //j从2遍历到3，把item[2]和item[3]变为''
         //for循环结束时，该子数组变为[2,2,0,0]，完成格子上移
         for(var j = cnt; j < item.length; j++) {
           item[j] = "";
         }
         return item;
       }
     ```

     （3-2）然后，遍历list数组，若找到某个格子和其前一个格子的数字相同且当前格子不是空格子，就把当前格子的数字加到其前一个格子上，当前格子的数字清零。

     ```js
     	for(var i = 0; i < this.size; i++) { 
           for(var j = 1; j < this.size; j++) {
             if(list[i][j-1]===list[i][j] && list[i][j]!=="") {//当前格子和左边的格子数字相同且都不是空格字
               list[i][j-1]+=list[i][j];//list数组当前遍历的数字加到左边那个格子的数字上
               list[i][j]="";//并把当前遍历的数字所在格子变为''
             }
           }
         }
     ```

     （3-3）重复（3-1），再次把数字向棋盘边界靠拢，保证当前用户的这一次操作所有能滑动合并的格子没有被落下。

     （4）生成一个局部变量res，暂时存放滑动合并后的棋盘数组。

     ​		遍历list数组，根据当前用户的这一次操作的方向把格子的值赋值给res，把res赋值给checkerboard的grid数组。

     ```js
     	var res = [];//局部变量
         if(this.size === 4){
           res = [[],[],[],[]];
         }else if(this.size===5){
           res = [[],[],[],[],[]];
         }
     //滑动合并数字后更新棋盘的格子
         for(var i = 0; i < this.size; i++) {
           for(var j = 0; j < this.size; j++) {
             switch (direction) {
               case 0://上
                 res[i][j] = list[j][i];
                 break;
               case 1://右
                 res[i][j] = list[i][this.size-1-j];
                 break;
               case 2://下
                 res[i][j] = list[j][this.size-1-i];
                 break;
               case 3://左
                 res[i][j] = list[i][j];
                 break;
             }
           }
         }
     ```

     （5）随机填充一个格子。

     ![1](/img/1.png)

     

   - **开发 5*5游戏模式**

     ​		5\*5游戏模式，即设计的困难模式，与4*4普通模式的区别在于棋盘的大小，通过在game.js和game_difficult.js的data中定义size，并分别定义为5和4，把页面样式（棋盘大小，格子大小）更改即能实现5\*5游戏模式。

     ​		与数据库交互详见【开发 服务器端（2）困难模式的网络请求部分】

     ![4](/img/4.png)

     

   - **开发 服务器端**

     ​		使用express+nodejs+mysql，通过express框架创建服务器，使用mysql数据库，将数据存储在数据库中，开发过程中数据库查看通过Navicat查看。
     
     **（1）游戏厅的网络请求部分**
     
     ​		当用户在游戏入口页（即首页）点击开始游戏按钮进入到游戏厅时，客户端向服务器发送网络请求，获取数据库中user表的当前用户的最高普通模式的成绩，把它set到game.js页面。
     
     ​		发送网络请求的代码如下：
     
     ```js
       //从数据库获取最高分
       getMaxScore() {
         wx.request({
           method: 'GET',
           url: 'http://127.0.0.1:3000/game/getMax/' + app.globalData.user_id, //当前登录用户的id
           //data:{},
           header: {
             'content-type': 'application/json'
           },
           success: (res) => {
             console.log(res.data)
             var tmp = -1
             if (res.data.msg.max_grade === null) { // 若数据库中还没有记录过成绩，就把tmp赋值0
               tmp = 0
             } else { // 否则赋值数据库中的成绩
               tmp = res.data.msg.max_grade
             }
     
             this.setData({
               maxScore: tmp
             })
           },
           fail: () => {
             console.log("普通模式最高成绩获取失败！")
           }
         })
       }
     ```
     
     ​		服务器中的接收客户端网络请求的代码如下：
     
     ```js
     //获取最高成绩
     module.exports.getMax = (req, res) => {
       console.log(req.params) //获得请求体
       let param = [req.params.id] //sql语句参数进行处理
       var sql = "select max_grade from user where id=?;"; //sql语句
       pool.query(sql, param, (error, result) => { //第一个参数sql语句，第二个参数是sql语句的参数
         if (error) { //有错误
           res.json({
             status: "400",
             data: '普通模式获取最高成绩失败',
             msg: error
           })
         } else { //成功
           console.log(result[0])
           res.json({
             status: "200",
             data: '普通模式获取最高成绩成功',
             msg: result[0]
           })
         }
       });
     }
     ```
     
     
     
     **（2）困难模式的网络请求部分**
     
     ​		与普通模式的网络请求类似，当用户在游戏入口页（即首页）点击困难模式按钮进入到游戏厅时，客户端向服务器发送网络请求，获取数据库中user表的当前用户的最高困难模式的成绩，把它set到game_difficult.js页面。
     
     ​		发送网络请求的代码如下：
     
     ```js
       //从数据库获取困难模式最高分
       getMaxScore() {
         wx.request({
           method: 'GET',
           url: 'http://127.0.0.1:3000/game/difficult/getMax/' + app.globalData.user_id, //当前登录用户的id
           //data:{},
           header: {
             'content-type': 'application/json'
           },
           success: (res) => {
             console.log(res.data)
             var tmp = -1
             if (res.data.msg.max_difficult_grade === null) { // 若数据库中还没有记录过成绩，就把tmp赋值0
               tmp = 0
             } else { // 否则赋值数据库中的成绩
               tmp = res.data.msg.max_difficult_grade
             }
     
             this.setData({
               maxScore: tmp
             })
           },
           fail: () => {
             console.log("困难模式最高成绩获取失败！")
           }
         })
       },
     ```
     
     ​		服务器中的接收客户端网络请求的代码如下：
     
     ```js
     //获取困难模式的最高成绩
     module.exports.getMaxDifficult = (req, res) => {
       console.log(req.params) //获得请求体
       let param = [req.params.id] //sql语句参数进行处理
       var sql = "select max_difficult_grade from user where id=?;"; //sql语句
       pool.query(sql, param, (error, result) => { //第一个参数sql语句，第二个参数是sql语句的参数
         if (error) { //有错误
           res.json({
             status: "400",
             data: '获取困难模式的最高成绩失败',
             msg: error
           })
         } else { //成功
           console.log(result[0])
           res.json({
             status: "200",
             data: '获取困难模式的最高成绩成功',
             msg: result[0]
           })
         }
       });
     }
     ```
     
     
     
     **（3）数据库表结构**
     
     ​		user表表结构如下：
     
     ![2](/img/2.png)
     
     ​		record表表结构如下：
     
     ![3](/img/3.png)
     
     
     
     **（4）服务器的保存成绩和添加记录部分**
     
     ​		普通模式保存当前成绩客户端：
     
     ```js
       //保存当前分数到数据库
       saveCurScore() {
         //更新user表中的数据
         wx.request({
           method: 'POST',
           url: 'http://127.0.0.1:3000/game/save',
           data: {
             cur_grade: this.data.score, //成绩
             id: app.globalData.user_id //当前用户的用户id
           },
           header: {
             "Content-Type": "application/x-www-form-urlencoded"
           },
           success: (res) => {
             console.log(res)
           },
           fail: () => {
             console.log("普通模式成绩保存失败！")
           }
         })
       }
     ```
     
     ​		服务器端：
     
     ```js
     //保存游戏的成绩
     module.exports.save = async (req, res) => {
       console.log(req.body) //获得请求体
       let params = [req.body.cur_grade, req.body.id] //sql语句参数进行处理
       var sql = "update user set cur_grade=? where id=?;"; //sql语句
       pool.query(sql, params, (error, result) => { //第一个参数sql语句，第二个参数是sql语句的参数
         if (error) { //有错误
           res.json({
             status: "400",
             data: '普通模式保存成绩失败',
             msg: error
           })
           console.log("普通模式保存成绩失败")
         } else { //成功
           res.json({
             status: "200",
             data: '普通模式保存成绩成功',
             msg: result
           })
           console.log("普通模式保存成绩成功")
         }
       });
     }
     ```
     
     ----------------------------------------------------------------------------------------------------------------------------
     
     ​		普通模式保存最高成绩客户端：
     
     ```js
       //保存最高分数到数据库
       saveMaxScore() {
         wx.request({
           method: 'POST',
           url: 'http://127.0.0.1:3000/game/saveMax',
           data: {
             max_grade: this.data.score, //最高成绩
             id: app.globalData.user_id //当前用户的用户id
           },
           header: {
             "Content-Type": "application/x-www-form-urlencoded"
           },
           success: (res) => {
             console.log(res)
           },
           fail: () => {
             console.log("普通模式最高成绩保存失败！")
           }
         })
       }
     ```
     
     ​		服务器端：
     
     ```js
     //保存游戏的最高成绩
     module.exports.saveMax = async (req, res) => {
       console.log(req.body) //获得请求体
       let params = [req.body.max_grade, req.body.id] //sql语句参数进行处理
       var sql = "update user set max_grade=? where id=?;"; //sql语句
       pool.query(sql, params, (error, result) => { //第一个参数sql语句，第二个参数是sql语句的参数
         if (error) { //有错误
           res.json({
             status: "400",
             data: '普通模式保存最高成绩失败',
             msg: error
           })
           console.log("普通模式保存最高成绩失败")
         } else { //成功
           res.json({
             status: "200",
             data: '普通模式保存最高成绩成功',
             msg: result
           })
           console.log("普通模式保存最高成绩成功")
         }
       });
     }
     ```
     
     ----------------------------------------------------------------------------------------------------------------------------
     
     ​		普通模式添加一条游戏记录客户端：
     
     ```js
       //向record表添加数据
       saveAnRecord() {
         wx.request({
           method: 'POST',
           url: 'http://127.0.0.1:3000/record/save',
           data: {
             cur_grade: this.data.score, //成绩
             create_time: util.formatTime(new Date()), //当前时间
             id: app.globalData.user_id, //当前用户的用户id
             game_mode: 0 //游戏模式（0为普通模式）
           },
           header: {
             "Content-Type": "application/x-www-form-urlencoded"
           },
           success: (res) => {
             console.log(res)
           },
           fail: () => {
             console.log("普通模式成绩记录保存失败！")
           }
         })
       }
     ```
     
     ​		服务器端：
     
     ```js
     //保存游戏的记录
     module.exports.save = async (req, res) => {
       let params = [req.body.id, req.body.cur_grade, req.body.create_time, req.body.game_mode] //sql语句参数进行处理
       var sql = "insert into record(user_id,cur_grade,create_time,game_mode) values(?,?,?,?);"; //sql语句
       pool.query(sql, params, (error, result) => { //第一个参数sql语句，第二个参数是sql语句的参数
         if (error) { //有错误
           res.json({
             status: "400",
             data: '普通模式保存成绩记录失败',
             msg: error
           })
         } else { //成功
           res.json({
             status: "200",
             data: '普通模式保存成绩记录成功',
             msg: result
           })
         }
       });
     }
     ```
     
     -----------------------------------------------------------------------------------------------------------------------------
     
     ​		困难模式与普通模式类似。
     
     
     
     **（5）配置过程**
     
     1、创建nodejs文件夹
     
     2、初始化项目，创建package.json
     
     `npm init -y`
     
     3、安装express框架
     
     `npm install express --save`
     
     4、安装nodemon以监控文件修改
     
     `npm install -g nodemon`
     
     5、在nodejs文件夹中创建index.js
     
     在index.js中写：
     
     ```js
     var express = require('express');
     var app = express();
     var bodyParser =require('body-parser');
     require("./database/dbconfig.js");
     
     var userRouter = require('./router/user.js');
     ... //导入更多的路由模块
     
     //增加头部信息解决跨域问题
     app.all('*', function (req, res, next){
       res.header("Access-Control-Allow-Origin", "*");
       res.header("Access-Control-Allow-Headers", "X-Requested-With");
       res.header("Access-Control-Allow-Methods","PUT,POST,GET,DELETE,OPTIONS");
       res.header('Access-Control-Allow-Headers', 'Content-Type, Content-Length, Authorization, Accept, X-Requested-With , yourHeaderFeild');
       res.header("X-Powered-By",' 3.2.1')
       res.header("Content-Type", "application/json;charset=utf-8");
       next();
     });
     
     //bodyParser解释前端提交数据
     app.use(bodyParser.urlencoded({extended:true}));// 配置解析表单数据的中间件
     app.use(bodyParser.json());
     
     // 导入并使用用户路由模块
     app.use('/user', userRouter);
     ... //使用更多的路由模块
     
     // 监听3000端口
     app.listen(3000, () => {
       console.log('server running at http://localhost:3000')
     })
     ```
     
     6、在nodejs文件夹中打开git bash
     
     运行`nodemon index.js`命令
     
     待看到nodemon的相关信息后表示打开成功
     
     ![5](/img/5.png)
     
     7、在nodejs文件夹中创建database文件夹，进入其中，创建dbconfig.js，配置数据库连接的相关信息（这里使用createConnection方法创建连接对象）：
     
     ```js
     //nodejs/database/dbconfig.js
     
     const mysql = require('mysql') // 导入mysql模块
     
     var pool = mysql.createConnection({ // 创建mysql实例
       host:'127.0.0.1',
       port:'3306',
       user:'root',
       password:'root',
       database:'wechat2048'
     });
     
     module.exports = {
       pool
     }
     ```
     
     8、在nodejs文件夹中创建router文件夹，进入其中，创建user.js文件，设置路由：
     
     ```js
     var express = require('express');
     var router = express.Router();
     
     let userRouter = require("../controller/user.js"); // 调用controller中user.js中的方法
     
     //查找用户
     router.get('/searchUser', userRouter.searchUser)
     ...//更多的router调用
     
     module.exports = router;
     ```
     
     ​		game.js和record.js同理创建。
     
     9、在nodejs文件夹中创建controller文件夹，进入其中，创建user.js文件，设置接受网络请求的方法：
     
     ```js
     let { pool } = require("../database/dbconfig.js")
     
     //查找用户
     module.exports.searchUser = async (req,res) =>{
       let sql="select id from user where user_name = ?;" //sql语句
       var name = req.query.name;
       pool.query(sql,name,function(error, result){
         if(error) { //有错误
           res.json({
             status: "400",
             data: '查询用户失败',
             msg: ''
           })
           console.log("查询用户失败")
         }else { //成功
           res.json({
             status: "200",
             data: '查询用户成功',
             msg: result
           })
           console.log("查询成功，结果是: ",result)
         }
       });
     }
     
     ...//更多的方法
     ```
     
     
     
   - **使用 flap（js语言新特性） 技术**

     ​		flap是一种新的js语言特性，它允许干净地强制执行完整性条件并修改函数的输入和输出。并可以将其视为函数的通用数据流包装器。
     
     ​		<u>使用方法：</u>
     
     ```js
     //1.在项目文件夹的终端中运行：
     npm i flap
     //安装flap依赖
     ```
     
     ```js
     //2.在nodejs/controller/game.js中引入
     var flap = require('flap') //引入flap
     ```
     
     ```js
     //3.在接口处理函数中写实现方法
     	//这里对要传到数据库中的成绩数据进行判零的操作
     //使用flap对成绩进行处理
     console.log("flap之前：" + req.body.cur_grade) //测试
     const max = (...args) => args.reduce((pre, cur) => pre > cur ? pre : cur) //取最大值
     const flap_max = flap.guard(max).map(arg => arg > 0 ? arg : 0) //flap对参数为0的时候把值为0
     console.log("flap之后：" + flap_max(0, req.body.cur_grade)) //测试
     let params = [flap_max(0, req.body.cur_grade), req.body.id] //sql语句参数进行处理
     ```
     
     ​		在localhost:3000/game/save、localhost:3000/game/saveMax、localhost:3000/game/difficult/save、localhost:3000/game/difficult/saveMax四个接口中实现了flap方法。
     
     ![6](/img/6.png)
     
     ​		flap具有的优点如下：
     
     ```
     1、用Elixir和Haskell等语言中的保护子句包装JS函数及其参数
     2、优雅地修改和响应基于表达式的参数
     3、针对对象参数的模式匹配
     4、通过链接离散逻辑单元提高复杂条件的可读性
     5、有助于防止深层嵌套和回调地狱
     6、可以选择绑定到函数。最大糖度原型
     ```
     
     
     
   - 开发 

     
     
   - 开发

     

3. 解决技术要点说明

   - **解决 nodejs服务器与微信小程序的数据交互 问题， 关键代码与步骤如下**

     ​		详见项目说明部分的【开发 服务器端——（4）服务器的保存成绩和添加记录部分】、【开发 服务器端——（5）配置过程】

     

   - 解决 xxx 问题， 关键代码与步骤如下

     

4. 心得体会（结合自己情况具体说明）

   - 大项目开发过程心得
     - 遇到哪些困难，经历哪里过程，有哪些收获
     
     - 张亦骞：
     
       
     
     - 张泽峰：
     
       
     
   - 本课程建议
     - 课程难度方面，进度方面，课程内容，授课方式等，给出你的意见
     
     - 张亦骞：
     
       
     
     - 张泽峰：
     
       
