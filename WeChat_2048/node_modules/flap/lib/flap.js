'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.flap = exports.Guard = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.guard = guard;
exports.bind = bind;
exports.unbind = unbind;

var _jsonWhere = require('json-where');

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Implements several chainable guard clauses, similar to those
 * found in languages such as Elixir and Ruby.
 *
 * Useful for extending the logic of functions in a non-invasive
 * manner and improving readability and/or learnability by reducing
 * deeply nested constructs / callback hell.
 */
var Guard = exports.Guard = function () {

  /**
   * Wraps a Function with a chainable guard clause object and then returns it
   * 
   * Note that as of version 1.0.0, a Function appended with Guard own 
   * properites is returned instead of a Guard! This allows the guarded function
   * to be directly invokable, so you no longer have to call `.value(..)` and can work
   * with it as you would any other Function. It does, however, come at the cost
   * of not being able to use `instanceof` or assert the prototype chain for `flap.Guard`
   *
   * @param {Function} func function to guard with clauses
   * @returns {Function} native Function with Guard own properties/methods appended
   */
  function Guard() {
    var _this = this;

    var func = arguments.length <= 0 || arguments[0] === undefined ? function (_) {} : arguments[0];

    _classCallCheck(this, Guard);

    this.func = func;

    Object.getOwnPropertyNames(Guard.prototype).forEach(function (prop) {
      if (prop !== 'constructor') {
        _this.func[prop] = _this[prop].bind(_this);
      }
    });

    return this.func;
  }

  /**
   * If `is` is truthy for the set of arguments, `then` will be called
   * with the arguments. Otherwise the original function in the Guard
   * will be called.
   *
   * @param {Function|String} is Function or JsonPath pattern to use as truthy condition
   * @param {Function} then callback Function for when `is` condition matches arguments
   * @returns {Function} new Guard function (identical to original if condition isn't met)
   * @example
   *
   * import flap from 'flap'
   *
   * const isEven = flap.guard(() => false)
   *   .map(parseInt) // ensure all arguments are numbers
   *   .when({
   *     is   : (x) = x % 2 === 0,
   *     then : (x) => true
   *   })
   *
   * isEven(1)   // -> false
   * isEven('6') // -> true
   */


  _createClass(Guard, [{
    key: 'when',
    value: function when(_ref) {
      var _this2 = this;

      var is = _ref.is;
      var then = _ref.then;

      if (is instanceof Function) {
        return new Guard(function () {
          return (is.apply(undefined, arguments) ? then : _this2.func).apply(undefined, arguments);
        });
      } else {
        return new Guard(function () {
          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          var matches = [];

          if (typeof is === 'string') {
            matches = args.filter(function (arg) {
              return (0, _jsonWhere.$)(is, arg).any();
            });
          } else if (is instanceof _jsonWhere.AbstractRef) {
            matches = args.filter(function (arg) {
              return is.any(arg);
            });
          }

          return matches.length ? then.apply(undefined, _toConsumableArray(matches)) : _this2.func.apply(_this2, args);
        });
      }

      return this;
    }

    /**
     * Unless `is` is true, call `then` instead of the original guarded function
     *
     * In other words, it essentially inverts original guarded function logic
     * by switching the original function with the newly provided `then` function
     * whenever `is` is truthy.
     *
     * @param {Function|String} is Function or JsonPath pattern to use as truthy condition
     * @param {Function} then callback Function for when `is` condition matches arguments
     * @returns {Guard} new Guard (identical to original if condition isn't met)
     */

  }, {
    key: 'unless',
    value: function unless(_ref2) {
      var is = _ref2.is;
      var then = _ref2.then;

      return new Guard(then).when({ is: is, then: this.func });
    }

    /**
     * When every argument is truthy for `is`, call `then`. Otherwise call
     * the original guarded function.
     *
     * @param {Function|String} is Function or JsonPath pattern to use as truthy condition
     * @param {Function} then callback Function for when `is` condition matches arguments
     * @returns {Guard} new Guard (identical to original if condition isn't met)
     */

  }, {
    key: 'all',
    value: function all(_ref3) {
      var _is = _ref3.is;
      var then = _ref3.then;

      return this.when({ is: function is() {
          for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }

          return args.length === args.filter(_is).length;
        }, then: then });
    }

    /**
     * When any argument is truthy for `is`, call `then`. Otherwise call
     * the original guarded function.
     *
     * @param {Function|String} is Function or JsonPath pattern to use as truthy condition
     * @param {Function} then callback Function for when `is` condition matches arguments
     * @returns {Guard} new Guard (identical to original if condition isn't met)
     */

  }, {
    key: 'any',
    value: function any(_ref4) {
      var _is2 = _ref4.is;
      var then = _ref4.then;

      return this.when({ is: function is() {
          for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
          }

          return args.filter(_is2).length;
        }, then: then });
    }

    /**
     * Processes arguments with `then` before any other functions in the guarded chain
     * are called.
     *
     * @param {Function} then callback Function for when `is` condition matches arguments
     * @returns {Guard} new Guard with `then` at the top of the chain
     */

  }, {
    key: 'before',
    value: function before(then) {
      var _this3 = this;

      return new Guard(function () {
        return _this3.func.apply(_this3, _toConsumableArray(then.apply(undefined, arguments)));
      });
    }

    /**
     * Processes final guarded chain result with `then`.
     *
     * @param {Function} then callback Function for when `is` condition matches arguments
     * @returns {Guard} new Guard with `then` at the bottom of the chain
     */

  }, {
    key: 'after',
    value: function after(then) {
      var _this4 = this;

      return new Guard(function () {
        return then(_this4.func.apply(_this4, arguments));
      });
    }

    /**
     * Maps each argument with `mapper`.
     *
     * @param {Function} mapper callback Function to call on each argument
     * @returns {Guard} new Guard with mapped arguments provided to original function
     */

  }, {
    key: 'map',
    value: function map(mapper) {
      var _this5 = this;

      return new Guard(function () {
        for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          args[_key4] = arguments[_key4];
        }

        return _this5.func.apply(_this5, _toConsumableArray(args.map(mapper)));
      });
    }

    /**
     * Filters arguments that match `is` (only those matching truthy will be passed in).
     *
     * @param {Function} is filter Function (truthy)
     * @returns {Guard} new Guard with filtered arguments provided to original function
     */
    // TODO: Consider retaining parameter arity instead of using a reductive filter

  }, {
    key: 'filter',
    value: function filter(is) {
      var _this6 = this;

      return new Guard(function () {
        for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
          args[_key5] = arguments[_key5];
        }

        return _this6.func.apply(_this6, _toConsumableArray(args.filter(is)));
      });
    }

    /**
     * Aborts guarded function chain completely if `is` condition is truthy.
     *
     * @param {Function} is condition to abort on
     * @returns {Guard} new Guard with appended abort `when` clause
     */

  }, {
    key: 'abort',
    value: function abort(is) {
      return this.when({ is: is, then: function then() {} });
    }
  }]);

  return Guard;
}();

/**
 * Convenience alias for flap.Guard constructor
 *
 * @param {Function} func function to wrap with chainable guard clauses
 * @returns {Guard} new chainable Guard
 */


function guard(func) {
  return new Guard(func);
}

/**
 * Sets a `guard` function onto the global `Function.prototype` object.
 * Allows `guard` object to be referenced on anonymous functions directly.
 *
 * @example
 *
 * import flap from 'flap'
 *
 * flap.bind()
 *
 * const divide = ((a,b) => a / b).guard.when({
 *   is   : (a,b) => b === 0,
 *   then : (a,b) => a / 1
 * })
 *
 * divide(6, 2) // -> 3
 * divide(6, 0) // -> 6 (0 is replaced by 1 via `when`)
 */
function bind() {
  Object.defineProperty(Function.prototype, 'guard', {
    enumerable: false,
    configurable: true,
    get: function get() {
      return new Guard(this.bind({}));
    }
  });
}

/**
 * Removes `guard` function from the global `Function.prototype` object.
 */
function unbind() {
  delete Function.prototype.guard;
}

/**
 * Module object definition.
 */
var flap = exports.flap = { guard: guard, bind: bind };

/**
 * Module export.
 */
exports.default = flap;